- 变量提升
  在JavaScript中，你声明一个变量  var a = 2; 时
  JavaScript 会将这串代码看成是两个声明：var a; 和 a = 2; 
  第一个定义声明是在编译阶段进行的。第二个赋值声明会被留在 原地等待执行阶段。
  - 在例1中，我们的代码会进行如下处理：
    var a;
    a = 2; 
    console.log( a );
    其中第一部分是编译，而第二部分是执行。
  
  - 例2中，我们的代码会进行如下处理：
    var b; 
    console.log( b ); 
    b = 2;

    也就是说，var b; 只有这串函数会被提升，而 b = 2;是不会被提升的
    因此，例2中将 var b = 2;  放在了 console.log( b ); 的下面时
    var b; 被提到最前面而 b = 2; 则呆在了原处，所以 console.log( b ); 会报 undefined 错误。
⚠️只有声明本身会被提升，而赋值或其他运行逻辑会留在原地。
  - 函数提升
    可见例3
    另外值得注意的是，每个作用域都会进行提升操作。尽管前面大部分的代码片段已经简化 了(因为它们只包含全局作用域)，而我们正在讨论的 foo(..) 函数自身也会在内部对 var a 进行提升(显然并不是提升到了整个程序的最上方)。因此这段代码实际上会被理解为下 面的形式:
      function foo() { 
        var a;
        a = 2;
        console.log( a ); // 2
      }
      foo();
    也就是说，变量提升只会提升到变量到当前作用域的顶部
⚠️函数声明会被提升，但是函数表达式却不会被提升
    可见例4
    这个例子中可以看成是 var foo;被提升了，而后面的 foo = function bar(){}却没有提升
    从而导致了在调用 foo(); 的时候，foo还不是一个函数，所以报错 TypeError
    那如果这个时候调用 bar(); 会出现什么结果呢？
    见例5
      可见 bar 没有被定义，也就是说，bar() 其实是foo里面的一个函数，他不在全局变量中，所
      以不能访问到这个函数
      这个代码片段经过提升后，实际上会被理解为以下形式:
        var foo;
        foo(); // TypeError
        bar(); // ReferenceError
        foo = function() {
          var bar = ...self... 
          // ...
        }