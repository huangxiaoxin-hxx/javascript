- 闭包
  - 概念
    外部函数调用之后其变量对象本应该被销毁，但闭包的存在使我们仍然可以访问外部函数的变量对象，这就是闭包的重要概念。
  - 特征
    (1)为创建内部作用域而调用了一个包装函数;
    (2)包装函数的返回 值必须至少包括一个对内部函数的引用，这样就会创建涵盖整个包装函数内部作用域的闭 包。
    
  - 循环和闭包
    可见 For-Closure.js 中的例1：
      正常情况下，我们对这段代码行为的预期是分别输出数字 1~5，每秒一次，每次一个。
      但实际上，这段代码在运行时会以每秒一次的频率输出五次 6。

      解释：
        首先这个循环的终止条件是 i 不再 <=5。条件首次成立时 i 的值是 6。因此，输出显示的是循环结束时 i 的最终值。
        延迟函数的回调会在循环结束时才执行。事实上，当定时器运行时即使每个迭代中执行的是setTimeout(.., 0)，所有的回调函数依然是在循环结束后才会被执行，因此会每次输出一个 6 出来。
    然而，就算有更多的闭包作用域（可见例2）也还是输出6，如果作用域是空的，那么仅仅将它们进行封闭是不够的。仔细看一下，我们的 IIFE 只是一 个什么都没有的空作用域。它需要包含一点实质内容才能为我们所用。
    它需要有自己的变量，用来在每个迭代中储存 i 的值：
      for (var i=1; i<=5; i++) { (function() {
        var j = i;
        setTimeout( function timer() {
          console.log( j );
          }, j*1000 );
        })(); 
      }

      可见例3
      我们将循环中的i值传递进去
      在迭代内使用 IIFE 会为每个迭代都生成一个新的作用域，使得延迟函数的回调可以将新的
      个迭代内部，每个迭代中都会含有一个具有正确值的变量供我们访问。
- 之前提到的块作用域中的 let：可以用来劫 持块作用域，并且在这个块作用域中声明一个变量。
    可见例4
    本质上这是将一个块转换成一个可以被关闭的作用域。

    for 循环头部的 let 声明还会有一 个特殊的行为。
    这个行为指出变量在循环过程中不止被声明一次，每次迭代都会声明。
    随后的每个迭代都会使用上一个迭代结束时的值来初始化这个变量。
    可见例5